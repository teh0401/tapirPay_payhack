import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.51.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const geminiApiKey = "xxx";

const supabase = createClient(supabaseUrl, supabaseServiceKey);

async function fetchWebContent(url: string): Promise<string> {
  try {
    console.log(`Fetching content from: ${url}`);
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; ESG-Bot/1.0)',
      },
    });
    
    if (!response.ok) {
      console.log(`Failed to fetch ${url}: ${response.status}`);
      return `Unable to fetch content from ${url}`;
    }
    
    const text = await response.text();
    // Simple text extraction - in production, you might want to use a proper HTML parser
    const cleanText = text
      .replace(/<script[^>]*>.*?<\/script>/gis, '')
      .replace(/<style[^>]*>.*?<\/style>/gis, '')
      .replace(/<[^>]*>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
    
    // Limit content length for API efficiency
    return cleanText.substring(0, 3000);
  } catch (error) {
    console.error(`Error fetching ${url}:`, error);
    return `Error fetching content from ${url}`;
  }
}

async function evaluateWithGemini(merchantInfo: string): Promise<any> {
  const prompt = `
As an ESG (Environmental, Social, and Governance) expert, analyze this business and provide a comprehensive ESG evaluation:

${merchantInfo}

Please respond ONLY with a valid JSON object containing:
{
  "esg_score": number (0-100 overall ESG score),
  "esg_rating": string ("Low", "Medium", or "High"),
  "esg_reason": string (brief explanation of the rating),
  "environmental_score": number (0-100 Environmental score),
  "social_score": number (0-100 Social score),
  "governance_score": number (0-100 Governance score),
  "esg_tags": array of strings (up to 5 most relevant ESG tags from this list: "Local Business", "Eco-Friendly", "Women-Led", "Fair Trade", "Recycled Materials", "Carbon Neutral", "Community Support", "Ethical Sourcing", "Diversity & Inclusion", "Renewable Energy", "Transparent Practices", "Minority-Owned", "Organic Products", "Zero Waste", "Employee Wellness", "B-Corp Certified", "Philanthropic", "Sustainable Packaging", "Local Sourcing", "Ethical Leadership")
}

Base your evaluation on sustainability practices, social impact, ethical business practices, and governance transparency. If information is limited, provide conservative but fair estimates.`;

  try {
    console.log('Calling Gemini API...');
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: prompt
              }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.1,
          topK: 1,
          topP: 1,
          maxOutputTokens: 500,
        }
      }),
    });

    if (!response.ok) {
      console.error('Gemini API error:', response.status, await response.text());
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    console.log('Gemini response:', data);

    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!generatedText) {
      throw new Error('No content generated by Gemini');
    }

    // Try to parse JSON from the response
    const jsonMatch = generatedText.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      
      // Validate and ensure proper structure
      if (typeof result.esg_score === 'number' && 
          typeof result.esg_rating === 'string' && 
          typeof result.esg_reason === 'string') {
        
        // Ensure scores are within valid range
        result.esg_score = Math.max(0, Math.min(100, result.esg_score));
        result.environmental_score = Math.max(0, Math.min(100, result.environmental_score || 50));
        result.social_score = Math.max(0, Math.min(100, result.social_score || 50));
        result.governance_score = Math.max(0, Math.min(100, result.governance_score || 50));
        
        // Ensure esg_tags is an array and limit to 5 items
        if (!Array.isArray(result.esg_tags)) {
          result.esg_tags = ['Local Business'];
        } else {
          result.esg_tags = result.esg_tags.slice(0, 5);
        }
        
        return result;
      }
    }

    // Fallback parsing if JSON structure is not perfect
    const scoreMatch = generatedText.match(/(\d+)/);
    const ratingMatch = generatedText.match(/(High|Medium|Low)/i);
    
    return {
      esg_score: scoreMatch ? parseInt(scoreMatch[1]) : 50,
      esg_rating: ratingMatch ? ratingMatch[1] : 'Medium',
      esg_reason: 'Evaluation based on available business information',
      environmental_score: 50,
      social_score: 50,
      governance_score: 50,
      esg_tags: ['Local Business']
    };
    
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    // Return default values on error
    return {
      esg_score: 50,
      esg_rating: 'Medium',
      esg_reason: 'ESG evaluation pending - please try again later',
      environmental_score: 50,
      social_score: 50,
      governance_score: 50,
      esg_tags: ['Local Business']
    };
  }
}

async function assignESGTags(supabase: any, merchantId: string, tagNames: string[]) {
  try {
    // Get tag IDs from tag names
    const { data: tags, error: tagsError } = await supabase
      .from('esg_tags')
      .select('id, name')
      .in('name', tagNames);

    if (tagsError) {
      console.error('Error fetching ESG tags:', tagsError);
      return;
    }

    // Clear existing auto-assigned tags
    await supabase
      .from('merchant_esg_tags')
      .delete()
      .eq('merchant_id', merchantId)
      .eq('is_auto_assigned', true);

    // Insert new tags
    if (tags && tags.length > 0) {
      const tagInserts = tags.map((tag: any) => ({
        merchant_id: merchantId,
        tag_id: tag.id,
        is_auto_assigned: true
      }));

      const { error: insertError } = await supabase
        .from('merchant_esg_tags')
        .insert(tagInserts);

      if (insertError) {
        console.error('Error inserting ESG tags:', insertError);
      } else {
        console.log('Successfully assigned ESG tags:', tagNames);
      }
    }
  } catch (error) {
    console.error('Error in assignESGTags:', error);
  }
}

async function createMerchantIncentives(supabase: any, merchantId: string) {
  try {
    // Check if incentives record already exists
    const { data: existing } = await supabase
      .from('merchant_incentives')
      .select('id')
      .eq('merchant_id', merchantId)
      .maybeSingle();

    if (!existing) {
      // Create new incentives record
      const { error } = await supabase
        .from('merchant_incentives')
        .insert({
          merchant_id: merchantId,
          total_impact_transactions: 0,
          discount_rate: 2.5,
          has_esg_badge: false,
          is_featured: false,
          tier: 'bronze'
        });

      if (error) {
        console.error('Error creating merchant incentives:', error);
      } else {
        console.log('Created merchant incentives record');
      }
    }
  } catch (error) {
    console.error('Error in createMerchantIncentives:', error);
  }
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('ESG evaluation request received');
    const { profileId, merchantData } = await req.json();

    if (!profileId || !merchantData) {
      throw new Error('Missing required parameters');
    }

    console.log('Merchant data:', merchantData);

    // Collect merchant information including description
    let merchantInfo = `Business Name: ${merchantData.business_name}\nBusiness Type: ${merchantData.business_type}\n`;
    
    if (merchantData.business_description) {
      merchantInfo += `Business Description: ${merchantData.business_description}\n`;
    }
    
    merchantInfo += '\n';

    const urls = [
      merchantData.website_url,
      merchantData.instagram_url,
      merchantData.facebook_url,
      merchantData.linkedin_url,
    ].filter(Boolean);

    console.log('Fetching content from URLs:', urls);

    if (urls.length > 0) {
      merchantInfo += "Online Presence Content:\n";
      
      for (const url of urls) {
        const content = await fetchWebContent(url);
        merchantInfo += `\n--- Content from ${url} ---\n${content}\n`;
      }
    } else {
      merchantInfo += "No online presence URLs provided.\n";
    }

    console.log('Prepared merchant info length:', merchantInfo.length);

    // Evaluate with Gemini
    const evaluation = await evaluateWithGemini(merchantInfo);
    console.log('ESG evaluation result:', evaluation);

    // Update the merchant profile with comprehensive ESG results
    const { error: updateError } = await supabase
      .from('merchant_profiles')
      .update({
        esg_score: evaluation.esg_score,
        esg_rating: evaluation.esg_rating,
        esg_reason: evaluation.esg_reason,
        environmental_score: evaluation.environmental_score,
        social_score: evaluation.social_score,
        governance_score: evaluation.governance_score,
        updated_at: new Date().toISOString(),
      })
      .eq('id', profileId);

    if (updateError) {
      console.error('Error updating merchant profile:', updateError);
      throw updateError;
    }

    // Process and assign ESG tags
    if (evaluation.esg_tags && evaluation.esg_tags.length > 0) {
      await assignESGTags(supabase, profileId, evaluation.esg_tags);
    }

    // Create or update merchant incentives
    await createMerchantIncentives(supabase, profileId);

    console.log('ESG evaluation completed successfully');

    return new Response(JSON.stringify({
      success: true,
      evaluation,
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Error in evaluate-esg function:', error);
    return new Response(JSON.stringify({ 
      error: error.message || 'Internal server error',
      success: false,
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});